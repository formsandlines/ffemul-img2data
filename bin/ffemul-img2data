#!/usr/bin/env bb

(ns ffemul-img2data
  (:require [babashka.process :refer [shell]]
            [babashka.fs :as fs]
            [clojure.java.io :as io]
            [clojure.pprint :as pprint]
            [clojure.edn :as edn]
            [clojure.string :as str]))

(def parse-int #(edn/read-string %))

(defn parse-line
  [line]
  (let [[pos-s rgb-s] (str/split line #" ")
        pos (mapv parse-int (-> pos-s
                                (subs 0 (dec (count pos-s)))
                                (str/split  #",")))
        rgb (mapv parse-int (-> rgb-s
                                (subs 1 (dec (count rgb-s)))
                                (str/split  #",")))]
    [pos rgb]))

(defn parse-size
  [size-s]
  (mapv edn/read-string (str/split size-s #",")))

(defn parse-image-data
  [img-data img-size cell-w stroke-w]
  (let [[width _] (parse-size img-size)
        cell-dist (+ cell-w stroke-w)
        data (->> (for [line (drop 1 (str/split img-data #"\n"))
                        :let [[[x y] rgb] (parse-line line)]
                        :when (and (= stroke-w (mod x cell-dist))
                                   (= stroke-w (mod y cell-dist)))]
                    (let [[r? g? b? :as xs] (map #(> % 50) rgb)
                          v (cond r? :U g? :I b? :M
                                  :else :N)]
                      (assert (< (count (filter true? xs)) 2))
                      v))
                  (partitionv (/ width cell-dist))
                  vec)]
    {:size [(count (first data)) (count data)]
     :data data}))

(defn read-image
  [input-file]
  {:size (:out (shell {:out :string} "identify" "-format" "%w,%h" input-file))
   :data (:out (shell {:out :string} "magick" input-file "txt:"))})

(defn write-edn
  [data file-path]
  (let [data-w (let [{:keys [size]} (if (map? data) data (first data))]
                 (first size))
        print-right-margin (let [data-row-length (+ 1 (* 3 data-w))]
                             (+ 7 data-row-length))]
    (try
      (with-open [wrtr (io/writer file-path)]
        (binding [*out* wrtr
                  pprint/*print-right-margin* print-right-margin]
          (pprint/pprint data)))
      (println "Output written to: " file-path)
      (catch Exception e
        (println "Error writing output: " (.getMessage e))))))

(defn process
  [input-file cell-w stroke-w]
  (let [input-file (fs/file input-file)
        {:keys [data size]} (try (read-image input-file)
                                 (catch Exception e
                                   (println "Error processing image: "
                                            (.getMessage e))))
        output (parse-image-data data size cell-w stroke-w)]
    (merge {:input (str input-file)
            :params {:cell-width cell-w
                     :stroke-width stroke-w}}
           output)))

(def valid-exts #{"png" "jpg"})

(defn batch-process
  [input-path & args]
  (let [files (->> (fs/list-dir input-path)
                   (filter #(and (not (fs/hidden? %))
                                 (valid-exts (fs/extension %))))
                   (sort))]
    (mapv #(apply process % args) files)))

(defn -main [& args]
  (if (< (count args) 2)
    (println "Usage: ffemul-img2data <input-file/dir> <output-file> <cell-width> <stroke-width>")
    (let [[input-path output-file cell-w stroke-w] args
          cell-w   (parse-int cell-w)
          stroke-w (parse-int stroke-w)
          edn-data (if (fs/directory? input-path)
                     (batch-process input-path cell-w stroke-w)
                     (process input-path cell-w stroke-w))]
      (write-edn edn-data output-file))))

(when (= *file* (System/getProperty "babashka.file"))
  (apply -main *command-line-args*))



(comment
  (def path (str (fs/cwd) "/test/"))
  (def filename "ex-file.png")

  (def raw (:out (shell {:out :string} "convert" (str path filename) "txt:")))

  (fs/directory? (str path filename))
  (fs/directory? (str path "ex-dir/"))

  (str (fs/path "./test/ex-file.png"))
  (process (str path filename) 3 1)

  (let [valid-exts #{"png" "jpg"}
        files (->> (fs/list-dir (str path "ex-dir/"))
                   (filter #(and (not (fs/hidden? %))
                                 (valid-exts (fs/extension %))))
                   (sort))]
    (map #(->> % (fs/relativize (fs/cwd)) str) files)
    #_
    (map fs/file-name files))

  (parse-size
   (:out (shell {:out :string} "identify" "-format" "%w,%h" (str path filename))))

  (->> (for [line (drop 1 (str/split raw #"\n"))
             :let [[[x y :as pos] rgb] (parse-line line)]
             :when (and (= 1 (mod x 4))
                        (= 1 (mod y 4)))]
         (let [[r? g? b? :as xs] (map #(> % 50) rgb)
               v (cond r? :U g? :I b? :M
                       :else :N)]
           (assert (< (count (filter true? xs)) 2))
           v))
       (partitionv (/ 640 4))
       (drop 1)
       (first)
       (take 14))

  (let [line "36,155: (48,48,47)  #30302F  srgb(48,48,47)"
        [pos-s rgb-s] (str/split line #" ")
        pos (mapv edn/read-string
                  (-> pos-s
                      (subs 0 (dec (count pos-s)))
                      (str/split  #",")))
        rgb (mapv edn/read-string
                  (-> rgb-s
                      (subs 1 (dec (count rgb-s)))
                      (str/split  #",")))]
    [pos rgb])

  (let [v (vec (repeat 20 :x))]
    (binding [pprint/*print-right-margin* Integer/MAX_VALUE
              ;; pprint/*print-miser-width* 61
              ]
      (pprint/pprint v)))

  
  ,)
